# Generated by Django 4.2.17 on 2025-01-21 14:32

from django.db import migrations, models

def choice_to_choice_set(apps, schema_editor):
    ChoiceModel = apps.get_model("question.Choice")
    ChoiceSetModel = apps.get_model("question.ChoiceSet")
    for choice in ChoiceModel.objects.all():
        linked_question = getattr(choice, 'question', None)
        if linked_question:
            cs, has_created_choice_set = ChoiceSetModel.objects.get_or_create(key=f"{linked_question.key}_choices")
            choice.set = cs
            if has_created_choice_set:
                linked_question.choices = cs
                linked_question.save()
            try:
                choice.save()
            except:
                choice.delete()  # we have more choices in the choice->question setup
    ChoiceModel.objects.filter(
        set__isnull=True
    ).delete()  # to be safe, delete choices without choice set

def choice_to_question(apps, schema_editor):
    ChoiceModel = apps.get_model("question.Choice")
    ChoiceSetModel = apps.get_model("question.ChoiceSet")
    QuestionModel = apps.get_model("question.Question")
    for question in QuestionModel.objects.all():
        choice_set = getattr(question, 'choices', None)
        if choice_set:
            ChoiceModel.objects.bulk_create(
                [
                    ChoiceModel(
                        question=question,
                        key=choice.key,
                        text=choice.text,
                        index=choice.index,
                    )
                    for choice in choice_set.choices.all()
                ]
            )
    ChoiceSetModel.objects.all().delete()  # to ensure we leave no dangling choices


class Migration(migrations.Migration):

    dependencies = [
        ('question', '0010_introduce_choiceset_and_more'),
    ]

    operations = [
        migrations.RunPython(choice_to_choice_set, reverse_code=choice_to_question),
    ]
